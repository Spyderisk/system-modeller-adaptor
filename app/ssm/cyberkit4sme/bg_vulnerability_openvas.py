##///////////////////////////////////////////////////////////////////////
##
## (c) University of Southampton IT Innovation Centre, 2021
##
## Copyright in this software belongs to University of Southampton
## IT Innovation Centre of Gamma House, Enterprise Road,
## Chilworth Science Park, Southampton, SO16 7NS, UK.
##
## This software may not be used, sold, licensed, transferred, copied
## or reproduced in whole or in part in any manner or form or in or
## on any media by any person other than in accordance with the terms
## of the Licence Agreement supplied with the software, or otherwise
## without the prior written consent of the copyright owners.
##
## This software is distributed WITHOUT ANY WARRANTY, without even the
## implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
## PURPOSE, except where stated in the Licence Agreement supplied with
## the software.
##
##      Created By :            Samuel Senior
##      Created Date :          2022-05-30
##      Created for Project :   Cyberkit4SME
##
##///////////////////////////////////////////////////////////////////////

import requests

from fastapi.logger import logger

from app.ssm.ssm_client import TWALevel

from app.ssm.cyberkit4sme.bg_vulnerability_base_twas import getVulnerabilityBaseTWAs

from app.core.config import NIST_API_KEY
from time import sleep


def cvss_base_v2(cvss_base_vector, cve=None):
    # Parses CVSS v2 base vectors for info

    if type(cvss_base_vector) is not list:
        cvss_base_vector = [cvss_base_vector]

    TWAs = getVulnerabilityBaseTWAs()

    logger.info(f"Processing CVSS base vector(s): {', '.join(cvss_base_vector)}")

    for cvss in cvss_base_vector:

        tmp_TWAs = getVulnerabilityBaseTWAs()

        # convert cvss base vector to python dictionary
        # "AV:N/AC:L/Au:N/C:P/I:P/A:P" -> {"AV": "N", ...}
        cvss_vectors = cvss.split('/')
        cvss_dict = {}
        for vector in cvss_vectors:
            tw_key, tw_value = vector.split(':')
            cvss_dict[tw_key] = tw_value


        # 1. Access Complexity - get trustworthiness level
        logger.info("1. Access Complexity - get trustworthiness level")
        if 'AC' in cvss_dict:
            if cvss_dict['AC'] == 'L':
                logger.info("Low trustworthiness level found")
                newTWALevel = 'Low'
            elif cvss_dict['AC'] == 'M':
                logger.info("Medium trustworthiness level found")
                newTWALevel = 'Medium'
            elif cvss_dict['AC'] == 'H':
                logger.info("High trustworthiness level found")
                newTWALevel = 'High'
            else:
                logger.error(f"Complexity {cvss_dict['AC']} is NOT supported")
                newTWALevel = None
        else:
            logger.info("CVSS Access Complexity NOT found")


        # 2. Access Vector
        logger.info("2. Access Vector")
        if 'AV' in cvss_dict:
            logger.info(f"parse Access Vector {cvss_dict['AV']}")
            TWA_label = None
            if cvss_dict['AV'] == 'L':
                logger.info("Local access exploitation found")
                cause = 'cvss_av: L'
                tmp_TWAs['Extrinsic-VL'] = newTWALevel
            elif cvss_dict['AV'] == 'A':
                logger.info("Local (physical or shell) network connection exploitation found")
                cause = 'cvss_av: A'
                tmp_TWAs['Extrinsic-VA'] = newTWALevel
            elif cvss_dict['AV'] == 'N':
                logger.info("Remote network connection exploitation found")
                cause = 'cvss_av: N'
                tmp_TWAs['Extrinsic-VN'] = newTWALevel

        else:
            logger.info("CVSS Access Vector NOT found")


        # 3. Authentication
        logger.info("3. Authentication")
        if 'Au' in cvss_dict:
            if cvss_dict['Au'] == 'N':
                logger.info("Authentication bypass exploitation found")
                cause = 'cvss_au: N'
                tmp_TWAs['Extrinsic-AU'] = newTWALevel
            else:
                logger.info("No authentication bypass exploitation found")
        else:
            logger.info("CVSS Authentication NOT found")


        # 4a. If there's CVEs then check for related CWEs and check those CWEs for cases of cross-site scripting or query injection
        logger.info("4. Check for cross-site scripting or query injection exploitation using CVE and CWE information")

        logger.info("4a. CVEs")
        if cve != None:
            logger.info(f"CVE(s) passed in: {', '.join(cve)}")

            cwes = process_CVEs(cve)

            # 4b. CWEs
            logger.info("4b. CWEs")
            if len(cwes) > 0:
                logger.info(f"Associated CWE(s): {', '.join(cwes)}")
                change_xs = change_qi = False
                for cwe in cwes:
                    if cwe in ['CWE-79', 'CWE-80', 'CWE-85', 'CWE-87', 'CWE-352']:
                        change_xs = True
                    if cwe in ['CWE-89', 'CWE-90', 'CWE-564', 'CWE-652']:
                        change_qi = True
            
                if change_xs:
                    logger.info("Cross-site scripting exploitation found")
                    cause = 'xs: true'
                    if "Extrinsic-XS" in tmp_TWAs:
                        tmp_TWAs['Extrinsic-XS'] = newTWALevel
                    elif "Extrinsic-SX" in tmp_TWAs:
                        tmp_TWAs['Extrinsic-SX'] = newTWALevel
                else:
                    logger.info("No cross-site scripting exploitation found")
                
                if change_qi:
                    logger.info("Query injection exploitation found")
                    cause = 'qi: true'
                    tmp_TWAs['Extrinsic-QI'] = newTWALevel
                else:
                    logger.info("No query injection exploitation found")
            else:
                logger.info(f"No CWE information found for CVE(s) {', '.join(cve)} and so no cross-site scripting or query injection exploitation found")
        else:
            logger.info(f"No CVE information found and so no CWE information and no cross-site scripting or query injection exploitation found")

        # 5. If XS or QI not found then map the CVSS base vector to C, I, A.
        logger.info("5. Mapping CVSS base vector to M or U or a C, I, A combination")
        if (("Extrinsic-XS" in tmp_TWAs and tmp_TWAs['Extrinsic-XS'] == None) or ("Extrinsic-SX" in tmp_TWAs and tmp_TWAs['Extrinsic-SX'] == None)) \
           and tmp_TWAs['Extrinsic-QI'] == None:

            # Special cases of CIA
            # 5a. Check if all Complete
            if (cvss_dict['C'] == 'C' and cvss_dict['I'] == 'C' and cvss_dict['A'] == 'C'):
                logger.info("Management rights exploitation found")
                cause = 'NOT (qi or xs) AND cvss_c: C cvss_i: C cvss_a: C'
                tmp_TWAs['Extrinsic-M'] = newTWALevel
            # 5b. Check if all Partial
            elif (cvss_dict['C'] == 'P' and cvss_dict['I'] == 'P' and cvss_dict['A'] == 'P'):
                logger.info("Local user access exploitation found")
                cause = 'NOT (qi or xs) AND cvss_c: P cvss_i: P cvss_a: P'
                tmp_TWAs['Extrinsic-U'] = newTWALevel
            # 5c. Else CIA
            else:
                if cvss_dict['C'] == 'C' or cvss_dict['C'] == 'P':
                    logger.info("Confidentiality exploitation found")
                    cause = 'NOT (qi or xs) AND cvss_c: C|P'
                    tmp_TWAs['Extrinsic-C'] = newTWALevel

                if cvss_dict['I'] == 'C' or cvss_dict['I'] == 'P':
                    logger.info("Integrity exploitation found")
                    cause = 'NOT (qi or xs) AND cvss_i: C|P'
                    tmp_TWAs['Extrinsic-I'] = newTWALevel

                if cvss_dict['A'] == 'C':
                    logger.info("Availability exploitation found")
                    cause = 'NOT (qi or xs) AND cvss_a: C'
                    tmp_TWAs['Extrinsic-A'] = newTWALevel
                elif cvss_dict['A'] == 'P':
                    logger.info("Availability exploitation found")
                    cause = 'NOT (qi or xs) AND cvss_a: P'

                    # May want a partial TWA reduction here
                    tmp_TWAs['Extrinsic-A'] = newTWALevel
                else:
                    logger.info("No mapping between CVSS base vector and M or U or C, I, A combination found")
        else:
            logger.info("Skipping as mapping already found between CVSS base vector and cross-site scripting or query injection exploitation")

        # Compare TWAs to see if worse or not
        logger.info("6. Comparing TWA values from the CVSS base vector(s) to keep the worst")
        for twa, newTWAValue in tmp_TWAs.items():
            if newTWAValue == None:
                pass
            elif TWAs[twa] == None:
                logger.info(f"Setting TWA {twa} to {newTWAValue}")
                TWAs[twa] = newTWAValue
            elif TWALevel[newTWAValue.upper()] < TWALevel[TWAs[twa].upper()]:
                logger.info(f"Changing TWA {twa}: {TWAs[twa]} -> {newTWAValue}")
                TWAs[twa] = newTWAValue
            else:
                logger.info(f"Change to TWA {twa} does not make TWA worse, keeping previous value")

    logger.info("CVSS base vector(s) processed")

    return TWAs

def process_CVEs(cves):

    cwes = []
    logger.info(f"Checking CVE(s) {', '.join(cves)} for related CWE(s)")
    for cve in cves:
        if NIST_API_KEY != "":
            logger.info(f"Using NIST API key")
            nist_rest_call = f"https://services.nvd.nist.gov/rest/json/cve/1.0/{cve}?apiKey={NIST_API_KEY}"
        else:
            nist_rest_call = f"https://services.nvd.nist.gov/rest/json/cve/1.0/{cve}"
        attempts = 0
        while attempts < 5:
            try:
                cve_info = requests.get(nist_rest_call).json()
                if "error" in cve_info and cve_info["error"] == "Invalid apiKey":
                    logger.info(f"Invalid apiKey, doing request without NIST API key...")
                    cve_info = requests.get(f"https://services.nvd.nist.gov/rest/json/cve/1.0/{cve}").json()
                break
            except Exception as ex:
                logger.info(f"{ex}")
                logger.info("Retrying retrieving of CVE data from NIST in 6 seconds...")
                attempts += 1
                sleep(6)
        if attempts == 5:
            logger.error("Maximum number of attempts reached for retrieving CVE data from NIST, exiting...")
            raise Exception("Maximum number of attempts reached for retrieving CVE data from NIST")

        if cve_info['result']['CVE_data_version'] == "4.0":
            for cve_items in cve_info['result']['CVE_Items']:
                for problemtype in cve_items['cve']['problemtype']['problemtype_data']:
                    cwes_tmp = []
                    for desc in problemtype['description']:
                        if desc['value'][0:3] == "CWE":
                            logger.info(f"Found CWE {desc['value']} for CVE {cve}")
                            cwes_tmp.append(desc['value'])
                    if len(cwes_tmp) == 0:
                        logger.info(f"Unable to find CWE for CVE {cve}")
                    else:
                        cwes += cwes_tmp
        else:
            logger.error(f"Unable to process CVE {cve} due to currently unsupported CVE data version: {cve_info['result']['CVE_data_version']}")

    if len(cwes) == 0:
        logger.info(f"Unable to find CWE(s) for given CVE(s)")

    else:
        return cwes

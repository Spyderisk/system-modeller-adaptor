##///////////////////////////////////////////////////////////////////////
##
## (c) University of Southampton IT Innovation Centre, 2021
##
## Copyright in this software belongs to University of Southampton
## IT Innovation Centre of Gamma House, Enterprise Road,
## Chilworth Science Park, Southampton, SO16 7NS, UK.
##
## This software may not be used, sold, licensed, transferred, copied
## or reproduced in whole or in part in any manner or form or in or
## on any media by any person other than in accordance with the terms
## of the Licence Agreement supplied with the software, or otherwise
## without the prior written consent of the copyright owners.
##
## This software is distributed WITHOUT ANY WARRANTY, without even the
## implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
## PURPOSE, except where stated in the Licence Agreement supplied with
## the software.
##
##      Created By :            Samuel Senior
##      Created Date :          2022-05-30
##      Created for Project :   Cyberkit4SME
##
##///////////////////////////////////////////////////////////////////////

import time, json

from fastapi import HTTPException
from fastapi.logger import logger

from app.ssm.ssm_client import SSMClient, TWALevel
from ssm_api_client.exceptions import ApiException

from app.models.session import SessionLockEnum
from app.models.state_report import *

from app.crud.store import update_status, get_vjob
from app.crud.store import release_session_lock, get_session
from app.crud.store_state_report import store_state_report

from app.ssm.protego.bg_rollback_utils import store_twas

from app.ssm.cyberkit4sme.bg_vulnerability_openvas_parser import OpenVASParser
from app.ssm.cyberkit4sme.bg_vulnerability_openvas import cvss_base_v2
from app.ssm.cyberkit4sme.bg_vulnerability_base_twas import getVulnerabilityBaseTWAs


def compose_causation(alert, vulnerability_metrics):
    """ compose alert causation string """

    cause = ""
    for metric in vulnerability_metrics:
        if metric[0] in alert:
            if cause != "":
                cause += ", "
            cause += f"{metric[0]}: {', '.join(alert[metric[0]])}"
            cause_additional= [f"{additionalArg}: {', '.join(alert[additionalArg])}" for additionalArg in metric[2] if additionalArg in alert]
            if len(cause_additional) > 0:
                cause += ", " + ", ".join(cause_additional)

    return cause

# models/{model_id}/notify/openvas-report-old
# Deprecated
async def bg_vulnerability_mapper(model_id: str, vjid: str,
                                  vuln_rep_file_names: str, vuln_type: str,
                                  db_conn, ssm_client: SSMClient, assetsDict: dict):
    """ background method to update vulnerabilities from a vulnerability scanner report """

    p_vul_start = time.perf_counter()

    try:
        session = await get_session(db_conn, model_id)
        if session.task_id != vjid or session.status != SessionLockEnum.locked:
            logger.error(f"Session lock does not match task ID {session.task_id} != {vjid}")
            raise Exception("model failed to verify lock")

        await update_status(db_conn, vjid, "RUNNING")

        # Check whether the model exists (via basic model info)
        model = ssm_client.get_model_info(model_id)
        assert (model is not None)

        logger.info(f"A new request has been received for {model.name} with id {model.id}.")
        logger.info(f"Updating {vuln_type} vulnerabilities from files {vuln_rep_file_names}")

        for file in vuln_rep_file_names:
            bg_vuln_file_mapper(model_id=model_id, 
                                vuln_rep_file_name=file, vuln_type="OpenVAS",
                                db_conn=db_conn, ssm_client=ssm_client, assetsDict=assetsDict)

        # update job status
        await update_status(db_conn, vjid, "FINISHED")
        logger.info("Finished updating TWAs from vulnerability report(s)")

        if ssm_client.twa_changes:
            logger.debug(f"Recorded TWA changes len: {len(ssm_client.twa_changes)}, {ssm_client.twa_changes}")
            await store_twas(ssm_client, db_conn)
        else:
            logger.debug("No TWA changes recorded")

        p_vul_finish = time.perf_counter()
        logger.debug(f"Time stats: {len(vuln_rep_file_names)} vulnerability report(s) processed in {p_vul_finish - p_vul_start} sec")

    except Exception as ex:
        logger.error(f"Exception when calling vulnerability_mapper: {ex}")
        await update_status(db_conn, vjid, "FAILED", str(ex))
        raise HTTPException(status_code=500, detail="validation operation failed")
    finally:
        logger.info("releasing session lock")
        await release_session_lock(db_conn, vjid)

    return

def bg_vuln_file_mapper(model_id: str, 
                                  vuln_rep_file_name: str, vuln_type: str,
                                  db_conn, ssm_client: SSMClient, assetsDict: dict):
    logger.info(f"Parsing input report file {vuln_rep_file_name} using the {vuln_type} parser")

    if vuln_type == "OpenVAS":
        parser = OpenVASParser()
    else:
        logger.error(f"Unsupported vulnerability type {vuln_type}")
        raise Exception(f"Unsupported vulnerability type {vuln_type}")

    # Vulnerability metric types supported, in order to be used and using a
    # list to keep that order preserved.  Each entry in the list maps a
    # vulnerability metric to its respective TWA mapping function and
    # provides any additional vulnerability metrics that may be needed in
    # the respective mapping function. It takes the form [vulnerability
    # metric, TWA mapping function, additional vulnerability metric
    # arguments] where the vulnerability metric name matches that in the
    # report being read in.
    vulnerability_metrics = [["cvss_base_v2", cvss_base_v2, ["cve"]],
                                #["cve", None, []],
                                #["cwe", None, []],
                                #["wasc", None, []]
                            ]

    # Parse OpenVAS file to create report object
    report = parser.parse(vuln_rep_file_name)

    # Get the number of alerts to process for the given report
    logger.info(f"Number of alerts to process {len(report)}")

    for alert in report:

        logger.info(f"Processing alert {alert['id']}")

        logger.info(f"Asset identifiers: host: {alert['host']}, port: {alert['port']}")

        if type(alert['host']) == list:
            logger.warn(f"Multiple hosts present in alert, not currently supported")
        if type(alert['port']) == list:
            logger.warn(f"Multiple ports present in alert, not currently supported")

        hostAndPort = alert['host'] + "/" + alert['port']
        logger.info(f"hostAndPort: {hostAndPort}")

        if hostAndPort in assetsDict:
            asset = assetsDict[hostAndPort]
            logger.info(f"located asset in dict: {asset.id}")
        else:
            identifiers = [{'key': 'host', 'value': alert['host']},
                            {'key': 'port', 'value': alert['port']}]

            logger.debug(f"Recomposed identifiers: {identifiers}, {type(identifiers)}")

            asset = ssm_client.find_ssm_asset(identifiers, model_id)
            if not asset:
                logger.warning(f'Model asset not found for identifier: {identifiers}')
                logger.warning(f"\t└─> skipping alert {alert['id']}")
                #raise Exception(f'Model asset not found for identifier: {identifiers}')
                continue

            logger.info(f"adding asset to dict: {asset.id}")
            assetsDict[hostAndPort] = asset

        logger.debug(f"Examining asset: {asset.id}, {asset.label}")

        # Retrieve current TWAs from the retrieved asset
        #current_twas = asset.trustworthiness_attribute_sets
        current_twas = ssm_client.get_asset_twas(asset.id, model_id)
        logger.info(f"Retrieved current TWAs size: {len(current_twas)}")

        # Get the TWAs specific to the ZAP mapping type
        twasToUpdate = getVulnerabilityBaseTWAs()

        # for loop here to go over each supported vulnerbility information
        # in turn, looping over everything below, possibly up to the actual
        # SSM TWA update?
        for metric in vulnerability_metrics:
            if metric[0] in alert:
                logger.info(f"Processing {metric[0]} in alert {alert['id']}")

                newTWAs = metric[1](alert[metric[0]], **dict([(additionalArg, alert[additionalArg]) for additionalArg in metric[2] if additionalArg in alert]))

                logger.info(f"TWAs from {metric[0]}: {newTWAs}")

                # Check if new TWA levels are worse than current update
                # value, if so then replace, if not then skip
                for twa, newTWAValue in newTWAs.items():
                    if newTWAs[twa] == None:
                        pass
                    elif twasToUpdate[twa] == None:
                        logger.info(f"Setting alert TWA {twa} to {newTWAValue}")
                        twasToUpdate[twa] = newTWAValue
                    elif TWALevel[newTWAValue.upper()] < TWALevel[twasToUpdate[twa].upper()]:
                        logger.info(f"Changing alert TWA {twa}: {twasToUpdate[twa]} -> {newTWAValue}")
                        twasToUpdate[twa] = newTWAValue
                    else:
                        logger.info(f"Change to alert TWA {twa} does not make TWA worse, keeping previous value")
            else:
                pass

        logger.info(f"TWA set gained from vulnerability report alert: {twasToUpdate}")

        stem = f"http://it-innovation.soton.ac.uk/ontologies/" \
                f"trustworthiness/domain#TrustworthinessLevel"

        logger.info(f"Updating asset TWA set for worst TWAs from alert {alert['id']}")
        cause = compose_causation(alert, vulnerability_metrics)
        for twa_label, twa_level in twasToUpdate.items():
            if twa_level != None:
                vuln_alert_twa_uri = stem + twa_level
                ssm_client.update_twas(twa_label, current_twas, vuln_alert_twa_uri,
                        asset.id, asset.label, cause, model_id, track=False)

        logger.info("Asset TWAs updated from passed in vulnerability report alert")

# models/{model_id}/notify/openvas-report
async def bg_ingest_openvas_reports(model_id: str, vjid: str,
                                  vuln_rep_file_names: str, vuln_type: str,
                                  db_conn, ssm_client: SSMClient, assetsDict: dict):
    """ background method to ingest/store one or more OpenVAS scanner reports """

    p_vul_start = time.perf_counter()

    state_ids = []

    try:
        session = await get_session(db_conn, model_id)
        if session.task_id != vjid or session.status != SessionLockEnum.locked:
            logger.error(f"Session lock does not match task ID {session.task_id} != {vjid}")
            raise Exception("model failed to verify lock")

        await update_status(db_conn, vjid, "RUNNING")

        # Check whether the model exists (via basic model info)
        model = ssm_client.get_model_info(model_id)
        assert (model is not None)

        logger.info(f"A new request has been received for {model.name} with id {model.id}.")
        logger.info(f"Located {len(vuln_rep_file_names)} {vuln_type} files: {vuln_rep_file_names}")

        for file in vuln_rep_file_names:
            state_id = await ingest_openvas_report(model_id=model_id, 
                                vuln_rep_file_name=file, vuln_type="OpenVAS",
                                db_conn=db_conn, ssm_client=ssm_client, assetsDict=assetsDict)
            state_ids.append(state_id)

        # update job status
        await update_status(db_conn, vjid, "FINISHED")
        logger.info("Finished storing OpenVAS report(s)")

        p_vul_finish = time.perf_counter()
        logger.debug(f"Time stats: {len(vuln_rep_file_names)} vulnerability report(s) stored in {p_vul_finish - p_vul_start} sec")

    except ApiException as api_ex:
        logger.info(f"API exception: model not found {api_ex}")
        await update_status(db_conn, vjid, "FAILED")
        raise HTTPException(status_code=api_ex.status, detail=f"Model not found")
    except Exception as ex:
        logger.error(f"Exception when calling vulnerability_mapper: {ex}")
        await update_status(db_conn, vjid, "FAILED", str(ex))
        raise HTTPException(status_code=500, detail="validation operation failed")
    finally:
        logger.info("releasing session lock")
        await release_session_lock(db_conn, vjid)

    return state_ids

async def ingest_openvas_report(model_id: str, 
                                  vuln_rep_file_name: str, vuln_type: str,
                                  db_conn, ssm_client: SSMClient, assetsDict: dict):
    logger.info(f"Parsing input report file {vuln_rep_file_name} using the {vuln_type} parser")

    if vuln_type == "OpenVAS":
        parser = OpenVASParser()
    else:
        logger.error(f"Unsupported vulnerability type {vuln_type}")
        raise Exception(f"Unsupported vulnerability type {vuln_type}")

    # Vulnerability metric types supported, in order to be used and using a
    # list to keep that order preserved.  Each entry in the list maps a
    # vulnerability metric to its respective TWA mapping function and
    # provides any additional vulnerability metrics that may be needed in
    # the respective mapping function. It takes the form [vulnerability
    # metric, TWA mapping function, additional vulnerability metric
    # arguments] where the vulnerability metric name matches that in the
    # report being read in.
    vulnerability_metrics = [["cvss_base_v2", cvss_base_v2, ["cve"]],
                                #["cve", None, []],
                                #["cwe", None, []],
                                #["wasc", None, []]
                            ]

    # Parse OpenVAS file to create report object
    report = parser.parse(vuln_rep_file_name)
    logger.info("Parsed OpenVAS report:")
    logger.info(json.dumps(report, indent=4, sort_keys=False))

    # Initialise list of state items for report
    state_items = []

    # Get the number of alerts to process for the given report
    logger.info(f"Number of alerts to process {len(report)}")

    for alert in report:

        logger.info(f"Processing alert {alert['id']}")
        logger.info(json.dumps(alert, indent=4, sort_keys=False))

        logger.info(f"Asset identifiers: host: {alert['host']}, port: {alert['port']}")

        if type(alert['host']) == list:
            logger.warn(f"Multiple hosts present in alert, not currently supported")
        if type(alert['port']) == list:
            logger.warn(f"Multiple ports present in alert, not currently supported")

        """
        hostAndPort = alert['host'] + "/" + alert['port']
        logger.info(f"hostAndPort: {hostAndPort}")

        if hostAndPort in assetsDict:
            asset = assetsDict[hostAndPort]
            logger.info(f"located asset in dict: {asset.id}")
        else:
            identifiers = [{'key': 'host', 'value': alert['host']},
                            {'key': 'port', 'value': alert['port']}]

            logger.debug(f"Recomposed identifiers: {identifiers}, {type(identifiers)}")

            asset = ssm_client.find_ssm_asset(identifiers, model_id)
            
            if not asset:
                logger.warning(f'Model asset not found for identifier: {identifiers}')
                logger.warning(f"\t└─> skipping alert {alert['id']}")
                #raise Exception(f'Model asset not found for identifier: {identifiers}')
                continue

            logger.info(f"adding asset to dict: {asset.id}")
            assetsDict[hostAndPort] = asset

        logger.debug(f"Examining asset: {asset.id}, {asset.label}")
        """

        """
        # Retrieve current TWAs from the retrieved asset
        current_twas = ssm_client.get_asset_twas(asset.id, model_id)
        logger.info(f"Retrieved current TWAs size: {len(current_twas)}")
        """

        # Get the TWAs specific to the ZAP mapping type
        twasToUpdate = getVulnerabilityBaseTWAs()

        # for loop here to go over each supported vulnerbility information
        # in turn, looping over everything below, possibly up to the actual
        # SSM TWA update?
        for metric in vulnerability_metrics:
            if metric[0] in alert:
                logger.info(f"Processing {metric[0]} in alert {alert['id']}")

                newTWAs = metric[1](alert[metric[0]], **dict([(additionalArg, alert[additionalArg]) for additionalArg in metric[2] if additionalArg in alert]))

                logger.info(f"TWAs from {metric[0]}: {newTWAs}")

                # Check if new TWA levels are worse than current update
                # value, if so then replace, if not then skip
                for twa, newTWAValue in newTWAs.items():
                    if newTWAs[twa] == None:
                        pass
                    elif twasToUpdate[twa] == None:
                        logger.info(f"Setting alert TWA {twa} to {newTWAValue}")
                        twasToUpdate[twa] = newTWAValue
                    elif TWALevel[newTWAValue.upper()] < TWALevel[twasToUpdate[twa].upper()]:
                        logger.info(f"Changing alert TWA {twa}: {twasToUpdate[twa]} -> {newTWAValue}")
                        twasToUpdate[twa] = newTWAValue
                    else:
                        logger.info(f"Change to alert TWA {twa} does not make TWA worse, keeping previous value")
            else:
                pass

        logger.info(f"TWA set gained from vulnerability report alert: {twasToUpdate}")

        stem = f"http://it-innovation.soton.ac.uk/ontologies/" \
                f"trustworthiness/domain#TrustworthinessLevel"

        domain_prefix = "http://it-innovation.soton.ac.uk/ontologies/trustworthiness/domain#"

        logger.info(f"Updating asset TWA set for worst TWAs from alert {alert['id']}")
        cause = compose_causation(alert, vulnerability_metrics)
        logger.info(f"cause: {cause}")

        #assetDesc = AssetDesc(id=asset.id, label=asset.label)

        properties = []
        properties.append(AdditionalProperty(key="host", value=alert['host']))
        properties.append(AdditionalProperty(key="port", value=alert['port']))

        #logger.info(f"hostAndPort: {hostAndPort}")
        assetDesc = AssetDesc(properties=properties)
        logger.info(f"assetDesc: {assetDesc}")

        tw_items = []

        logger.info("Adding TWAS updates to state report:")
        for twa_label, twa_level in twasToUpdate.items():
            if twa_level != None:
                vuln_alert_twa_uri = stem + twa_level

                logger.info(f"{twa_label}: {vuln_alert_twa_uri}")

                """
                #Locate TWAS for the specified TWA label
                twas = get_twas_for_twa_label(current_twas, twa_label)

                if twas != None:
                    tw = Trustworthiness(trustworthinessAttributeSet=twas.uri, level=vuln_alert_twa_uri, operator=OperatorEnum.EQ)
                    # Add to state item TW list
                    tw_items.append(tw)
                else:
                    logger.warn(f"Could not locate TWAS for {twa_label}")
                """

                # Build TW attribute URI
                twa = domain_prefix + twa_label + "-TW"
                
                # Create Trustworthiness object using TW attribute and level
                tw = Trustworthiness(trustworthinessAttribute=twa, level=vuln_alert_twa_uri, operator=OperatorEnum.EQ)

                # Add to state item TW list
                tw_items.append(tw)

        state_item = StateItem(asset=assetDesc, trustworthiness=tw_items, impacts=[], controls=[])
        state_items.append(state_item)

    # Set expiry to "newest" and label as "openvas"
    expiry = [Expiry(type=ExpiryTypeEnum.newest, label="openvas")]

    # Create state report
    state_report = StateReportMessage(expiry=expiry, state=state_items)
    logger.info(f"Created state report:")
    logger.info(json.dumps(state_report.dict(), indent=4, sort_keys=False))

    # Store the state report
    state_id = await store_state_report(db_conn, model_id, state_report)
    logger.info(f"state_id: {state_id}")

    return state_id

def get_twas_for_twa_label(twas, twa_label):
    for tw_key, tw_val in twas.items():
        if tw_key.find(twa_label) >= 0:
            logger.debug(f"Located {twa_label}: {tw_val.uri}")
            return tw_val
